<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geographic Routing Performance Testing Tool</title>
    <meta name="description" content="Compare network routing performance across different geographic paths and infrastructure providers">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .header-nav {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        .nav-link {
            color: white;
            text-decoration: none;
            background: rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 20px;
            transition: all 0.3s;
            font-size: 14px;
        }

        .nav-link:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            min-height: 700px;
        }
        
        .sidebar {
            background: #f8f9fa;
            padding: 30px;
            border-right: 1px solid #e9ecef;
            overflow-y: auto;
            max-height: 100vh;
        }
        
        .content-area {
            padding: 30px;
        }
        
        .control-group {
            margin-bottom: 25px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .control-group h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
            font-family: inherit;
        }
        
        .form-group textarea {
            min-height: 60px;
            resize: vertical;
        }
        
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .route-entry {
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            background: #f8f9fa;
        }
        
        .route-entry.enabled {
            border-color: #3498db;
            background: #f0f8ff;
        }
        
        .route-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .route-checkbox {
            margin-right: 10px;
        }
        
        .route-type {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .route-type.traditional {
            background: #ffebee;
            color: #c62828;
        }
        
        .route-type.optimized {
            background: #e8f5e8;
            color: #2e7d32;
        }
        
        .route-type.reference {
            background: #e3f2fd;
            color: #1565c0;
        }
        
        .route-type.custom {
            background: #f3e5f5;
            color: #7b1fa2;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 14px;
            width: auto;
            margin: 5px 5px 0 0;
        }
        
        .results-container {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
            font-weight: 500;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            text-align: center;
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 5px;
        }
        
        .metric-label {
            color: #666;
            font-size: 0.9em;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            width: 0%;
            transition: width 0.3s;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .results-table th, .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }
        
        .results-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-running {
            background: #f39c12;
            animation: pulse 1.5s infinite;
        }
        
        .status-complete {
            background: #27ae60;
        }
        
        .status-idle {
            background: #95a5a6;
        }
        
        .status-error {
            background: #e74c3c;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .log-output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .endpoint-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        
        .endpoint-status.success {
            border-left-color: #27ae60;
        }
        
        .endpoint-status.error {
            border-left-color: #e74c3c;
        }
        
        .endpoint-status.testing {
            border-left-color: #f39c12;
        }
        
        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #856404;
        }
        
        .info-box {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #0c5460;
        }

        .success-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #155724;
        }

        .scenario-selector {
            margin-bottom: 20px;
        }

        .preset-scenarios {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .route-diagram {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                border-right: none;
                border-bottom: 1px solid #e9ecef;
                max-height: none;
            }
            
            .metric-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }

            .preset-scenarios {
                grid-template-columns: 1fr;
            }

            .header-nav {
                position: static;
                margin-top: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-nav">
                <a href="/docs.html" class="nav-link">📖 Documentation</a>
            </div>
            <h1>🌐 Geographic Routing Performance Testing Tool</h1>
            <p>Compare routing performance across different network paths and infrastructure providers</p>
        </div>
        
        <div class="main-content">
            <div class="sidebar">
                <div class="control-group">
                    <h3>🎯 Test Scenario</h3>
                    <div class="scenario-selector">
                        <div class="form-group">
                            <label>Preset Scenarios:</label>
                            <div class="preset-scenarios">
                                <button class="btn btn-small" onclick="loadPresetScenario('sa-au-nz')">SA→AU→NZ</button>
                                <button class="btn btn-small" onclick="loadPresetScenario('us-eu')">US→EU</button>
                                <button class="btn btn-small" onclick="loadPresetScenario('asia-pacific')">Asia Pacific</button>
                                <button class="btn btn-small" onclick="loadPresetScenario('custom')">Custom</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Scenario Description:</label>
                            <textarea id="scenario-description" placeholder="Describe your routing optimization scenario...">Testing SA→AU→NZ routing: Compare traditional ISP routing via Europe vs Google Cloud backbone routing via Australia</textarea>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>🧪 Test Configuration</h3>
                    <div class="form-group">
                        <label>Test Iterations:</label>
                        <input type="number" id="iterations" value="30" min="10" max="100">
                    </div>
                    <div class="form-group">
                        <label>Timeout (seconds):</label>
                        <input type="number" id="timeout" value="15" min="5" max="30">
                    </div>
                    <div class="form-group">
                        <label>Test Mode:</label>
                        <select id="testMode">
                            <option value="ping">Latency Test (HEAD requests)</option>
                            <option value="download">Download Test (1KB)</option>
                            <option value="comprehensive">Comprehensive Test</option>
                        </select>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>🛣️ Routing Endpoints</h3>
                    <div id="routing-endpoints">
                        <!-- Dynamic routing endpoints will be inserted here -->
                    </div>
                    <button class="btn btn-small" onclick="addCustomRoute()">+ Add Custom Route</button>
                </div>
                
                <div class="control-group">
                    <h3>⚙️ Actions</h3>
                    <button class="btn" onclick="runRoutingTests()">🚀 Run Performance Tests</button>
                    <button class="btn btn-success" onclick="exportResults()">📊 Export Results</button>
                    <button class="btn btn-warning" onclick="resetConfiguration()">🔄 Reset Config</button>
                    <button class="btn" onclick="testEndpointReachability()">🔍 Test Connectivity</button>
                </div>
                
                <div class="control-group">
                    <h3>📊 Test Status</h3>
                    <div id="status">
                        <span class="status-indicator status-idle"></span>
                        <span>Ready to test routing performance</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress"></div>
                    </div>
                    <div id="endpoint-status"></div>
                </div>
            </div>
            
            <div class="content-area">
                <div class="tabs">
                    <button class="tab active" onclick="showTab('overview')">📈 Performance Overview</button>
                    <button class="tab" onclick="showTab('detailed')">🔍 Detailed Results</button>
                    <button class="tab" onclick="showTab('analysis')">📊 Routing Analysis</button>
                    <button class="tab" onclick="showTab('logs')">📋 Test Logs</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    <div class="info-box">
                        <strong>🎯 Geographic Routing Performance Testing</strong><br>
                        This tool helps you measure and compare network routing performance across different paths.
                        Configure your routing scenarios below and run tests to identify the most efficient network paths.
                    </div>

                    <div id="scenario-visualization">
                        <div class="route-diagram">
<strong>CURRENT SCENARIO: SA→AU→NZ Routing Optimization</strong>

<span style="color: #c62828; font-weight: bold;">🔴 TRADITIONAL ISP ROUTING:</span>
South Africa → ISP → Europe (Marseille) → Asia Pacific → Australia/New Zealand

<span style="color: #2e7d32; font-weight: bold;">🟢 OPTIMIZED ROUTING (Google Cloud):</span>
South Africa → Google POP → Google Backbone → Australia VM → New Zealand

<span style="color: #1565c0; font-weight: bold;">🔗 HYBRID APPROACHES:</span>
Various combinations of direct connections, CDNs, and cloud infrastructure
                        </div>
                    </div>
                    
                    <div class="metric-grid">
                        <div class="metric-card">
                            <div class="metric-value" id="best-latency">--</div>
                            <div class="metric-label">Best Route Performance</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="worst-latency">--</div>
                            <div class="metric-label">Worst Route Performance</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="improvement-ms">--</div>
                            <div class="metric-label">Max Improvement</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="improvement-percent">--</div>
                            <div class="metric-label">Performance Gain</div>
                        </div>
                    </div>
                    
                    <div class="results-container">
                        <h3>🎯 Routing Performance Summary</h3>
                        <div id="summary-content">
                            <p>Configure your routing endpoints and run tests to compare performance across different network paths...</p>
                        </div>
                    </div>
                </div>
                
                <div id="detailed" class="tab-content">
                    <div class="results-container">
                        <h3>📊 Detailed Performance Metrics</h3>
                        <div id="detailed-results">
                            <p>No test results available. Run tests to see detailed measurements for each routing path.</p>
                        </div>
                    </div>
                </div>
                
                <div id="analysis" class="tab-content">
                    <div class="results-container">
                        <h3>🔍 Routing Optimization Analysis</h3>
                        <div id="analysis-content">
                            <p>Run tests to see comprehensive analysis including:</p>
                            <ul>
                                <li><strong>Route Performance Ranking:</strong> Compare all tested paths</li>
                                <li><strong>Consistency Analysis:</strong> Standard deviation and reliability metrics</li>
                                <li><strong>Geographic Insights:</strong> Understand the impact of routing choices</li>
                                <li><strong>Optimization Recommendations:</strong> Implementation guidance</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div id="logs" class="tab-content">
                    <div class="results-container">
                        <h3>📋 Test Execution Logs</h3>
                        <div class="log-output" id="log-output">
Geographic Routing Performance Testing Tool
==========================================
Ready to test routing performance across different network paths...

Configure your routing scenarios and run tests to begin analysis.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let testResults = null;
        let isRunning = false;
        let routeCounter = 0;

        // Preset routing scenarios
        const presetScenarios = {
            'sa-au-nz': {
                description: 'Testing SA→AU→NZ routing: Compare traditional ISP routing via Europe vs Google Cloud backbone routing via Australia',
                routes: [
                    {
                        name: 'Traditional Route (Europe)',
                        url: 'https://jsonplaceholder.typicode.com/posts/1',
                        type: 'traditional',
                        description: 'ISP routing via European hubs',
                        enabled: true
                    },
                    {
                        name: 'Google Cloud Australia',
                        url: 'https://www.googleapis.com/storage/v1/b',
                        type: 'optimized',
                        description: 'Google backbone via Australia',
                        enabled: true
                    },
                    {
                        name: 'CDN Australia',
                        url: 'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js',
                        type: 'reference',
                        description: 'CDN with Australian PoP',
                        enabled: true
                    },
                    {
                        name: 'Alternative Endpoint',
                        url: 'https://httpbin.org/delay/0',
                        type: 'reference',
                        description: 'CORS-friendly test endpoint',
                        enabled: false
                    }
                ],
                visualization: `
<strong>SCENARIO: SA→AU→NZ Routing Optimization</strong>

<span style="color: #c62828; font-weight: bold;">🔴 TRADITIONAL ISP ROUTING:</span>
South Africa → ISP → Europe (Marseille) → Asia Pacific → Australia/New Zealand

<span style="color: #2e7d32; font-weight: bold;">🟢 OPTIMIZED ROUTING (Google Cloud):</span>
South Africa → Google POP → Google Backbone → Australia VM → New Zealand
                `
            },
            'us-eu': {
                description: 'Testing US→EU routing: Compare transatlantic routing options and CDN performance',
                routes: [
                    {
                        name: 'US East Coast',
                        url: 'https://api.github.com',
                        type: 'reference',
                        description: 'US-based API endpoint',
                        enabled: true
                    },
                    {
                        name: 'EU Central',
                        url: 'https://httpbin.org/delay/0',
                        type: 'reference',
                        description: 'European endpoint',
                        enabled: true
                    },
                    {
                        name: 'Global CDN',
                        url: 'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js',
                        type: 'optimized',
                        description: 'Global CDN network',
                        enabled: true
                    }
                ],
                visualization: `
<strong>SCENARIO: US→EU Routing Performance</strong>

<span style="color: #c62828; font-weight: bold;">🔴 DIRECT ROUTING:</span>
Source → ISP → Transatlantic Cable → European ISP → Destination

<span style="color: #2e7d32; font-weight: bold;">🟢 CDN ROUTING:</span>
Source → Nearest CDN POP → CDN Backbone → European POP → Cache/Origin
                `
            },
            'asia-pacific': {
                description: 'Testing Asia Pacific routing: Compare intra-regional vs international routing paths',
                routes: [
                    {
                        name: 'Singapore Hub',
                        url: 'https://httpbin.org/delay/0',
                        type: 'reference',
                        description: 'Singapore-based endpoint',
                        enabled: true
                    },
                    {
                        name: 'Tokyo Hub',
                        url: 'https://api.github.com',
                        type: 'reference',
                        description: 'Japan-based endpoint',
                        enabled: true
                    },
                    {
                        name: 'Australia Hub',
                        url: 'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js',
                        type: 'optimized',
                        description: 'Australian endpoint',
                        enabled: true
                    }
                ],
                visualization: `
<strong>SCENARIO: Asia Pacific Regional Routing</strong>

<span style="color: #1565c0; font-weight: bold;">🔗 REGIONAL HUBS:</span>
Source → Regional ISP → Singapore/Tokyo/Sydney Hub → Destination

<span style="color: #2e7d32; font-weight: bold;">🟢 OPTIMIZED PATHS:</span>
Source → Submarine Cable → Direct Regional Connection → Destination
                `
            },
            'custom': {
                description: 'Custom routing scenario - configure your own endpoints and routing paths',
                routes: [
                    {
                        name: 'Custom Route 1',
                        url: 'https://example.com',
                        type: 'custom',
                        description: 'Your custom endpoint',
                        enabled: false
                    }
                ],
                visualization: `
<strong>CUSTOM SCENARIO: Define Your Own Routing Test</strong>

Configure your specific routing endpoints and network paths below.
Add multiple routes to compare different infrastructure options.
                `
            }
        };

        // Network Performance Tester Class - Generic Version
        class RoutingPerformanceTester {
            constructor() {
                this.logs = [];
                this.results = {};
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[${timestamp}] ${message}`;
                this.logs.push(logMessage);
                
                const logOutput = document.getElementById('log-output');
                logOutput.textContent += logMessage + '\n';
                logOutput.scrollTop = logOutput.scrollHeight;
            }

            async measureLatency(url, timeout = 15000) {
                const startTime = performance.now();
                
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    
                    const response = await fetch(url, {
                        method: 'HEAD',
                        mode: 'cors',
                        cache: 'no-cache',
                        signal: controller.signal,
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    const endTime = performance.now();
                    const latency = Math.round(endTime - startTime);
                    
                    return {
                        success: true,
                        latency: latency,
                        status: response.status,
                        url: url
                    };
                    
                } catch (error) {
                    const endTime = performance.now();
                    const latency = Math.round(endTime - startTime);
                    
                    return {
                        success: false,
                        latency: latency,
                        error: error.message,
                        url: url
                    };
                }
            }

            async testEndpoint(name, url, iterations, timeout) {
                this.log(`Testing ${name}: ${url}`);
                const results = [];
                
                for (let i = 0; i < iterations; i++) {
                    this.log(`  → ${name} test ${i + 1}/${iterations}`);
                    
                    const result = await this.measureLatency(url, timeout);
                    results.push(result);
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    this.updateEndpointStatus(name, `Testing... ${i + 1}/${iterations}`, 'testing');
                }
                
                return this.calculateStats(name, url, results);
            }

            calculateStats(name, url, results) {
                const successful = results.filter(r => r.success);
                const failed = results.filter(r => !r.success);
                
                if (successful.length === 0) {
                    this.log(`${name}: All requests failed`);
                    this.updateEndpointStatus(name, 'All requests failed', 'error');
                    return {
                        name,
                        url,
                        success: false,
                        successRate: 0,
                        totalTests: results.length,
                        allResults: results
                    };
                }
                
                const latencies = successful.map(r => r.latency);
                const sorted = [...latencies].sort((a, b) => a - b);
                const avg = latencies.reduce((a, b) => a + b, 0) / latencies.length;
                const variance = latencies.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / latencies.length;
                
                const stats = {
                    name,
                    url,
                    success: true,
                    successRate: Math.round((successful.length / results.length) * 100),
                    totalTests: results.length,
                    successfulTests: successful.length,
                    failedTests: failed.length,
                    min: Math.min(...latencies),
                    max: Math.max(...latencies),
                    average: Math.round(avg),
                    median: sorted[Math.floor(sorted.length / 2)],
                    standardDeviation: Math.round(Math.sqrt(variance)),
                    allResults: results,
                    latencies: latencies
                };
                
                this.log(`${name}: Avg ${stats.average}ms, Range ${stats.min}-${stats.max}ms, Success ${stats.successRate}%`);
                this.updateEndpointStatus(name, `Avg: ${stats.average}ms (${stats.successRate}% success)`, 'success');
                
                return stats;
            }

            updateEndpointStatus(name, status, type) {
                const statusContainer = document.getElementById('endpoint-status');
                let statusElement = statusContainer.querySelector(`[data-endpoint="${name}"]`);
                
                if (!statusElement) {
                    statusElement = document.createElement('div');
                    statusElement.className = 'endpoint-status';
                    statusElement.setAttribute('data-endpoint', name);
                    statusElement.innerHTML = `<span class="name">${name}</span><span class="status">${status}</span>`;
                    statusContainer.appendChild(statusElement);
                } else {
                    statusElement.querySelector('.status').textContent = status;
                }
                
                statusElement.className = `endpoint-status ${type}`;
            }

            async runTests() {
                const config = this.getConfiguration();
                const endpoints = this.getEnabledRoutes();
                
                if (endpoints.length === 0) {
                    throw new Error('No routing endpoints enabled for testing');
                }
                
                this.log(`🚀 Starting routing performance comparison`);
                this.log(`Testing ${endpoints.length} routing paths with ${config.iterations} iterations each`);
                this.log(`Timeout: ${config.timeout}s, Mode: ${config.testMode}`);
                
                const allResults = {};
                const totalTests = endpoints.length * config.iterations;
                let completedTests = 0;
                
                for (const endpoint of endpoints) {
                    try {
                        this.log(`\n🛣️  Testing route: ${endpoint.name}`);
                        const result = await this.testEndpoint(
                            endpoint.name, 
                            endpoint.url, 
                            config.iterations, 
                            config.timeout * 1000
                        );
                        
                        allResults[endpoint.name] = result;
                        completedTests += config.iterations;
                        
                        const progress = (completedTests / totalTests) * 100;
                        document.getElementById('progress').style.width = progress + '%';
                        
                    } catch (error) {
                        this.log(`❌ Error testing ${endpoint.name}: ${error.message}`);
                        this.updateEndpointStatus(endpoint.name, `Error: ${error.message}`, 'error');
                    }
                }
                
                this.log('\n✅ Routing performance tests completed!');
                this.log('📊 Generating performance analysis...');
                
                return {
                    timestamp: new Date().toISOString(),
                    config: config,
                    scenario: document.getElementById('scenario-description').value,
                    endpoints: allResults,
                    summary: this.generateSummary(allResults)
                };
            }

            generateSummary(results) {
                const successful = Object.values(results).filter(r => r.success);
                
                if (successful.length === 0) {
                    return {
                        totalEndpoints: Object.keys(results).length,
                        successfulEndpoints: 0,
                        bestRoute: null,
                        worstRoute: null,
                        improvement: null
                    };
                }
                
                const fastest = successful.reduce((min, r) => r.average < min.average ? r : min);
                const slowest = successful.reduce((max, r) => r.average > max.average ? r : max);
                const totalTests = Object.values(results).reduce((sum, r) => sum + r.totalTests, 0);
                const totalSuccessful = Object.values(results).reduce((sum, r) => sum + (r.successfulTests || 0), 0);
                const avgLatency = Math.round(successful.reduce((sum, r) => sum + r.average, 0) / successful.length);
                
                let improvement = null;
                if (fastest && slowest && fastest !== slowest) {
                    const improvementMs = slowest.average - fastest.average;
                    const improvementPercent = Math.round((improvementMs / slowest.average) * 100);
                    
                    improvement = {
                        latencyReduction: improvementMs,
                        percentageImprovement: improvementPercent
                    };
                }
                
                return {
                    totalEndpoints: Object.keys(results).length,
                    successfulEndpoints: successful.length,
                    bestRoute: fastest,
                    worstRoute: slowest,
                    improvement,
                    averageLatency: avgLatency,
                    overallSuccessRate: Math.round((totalSuccessful / totalTests) * 100),
                    routeRanking: successful.sort((a, b) => a.average - b.average)
                };
            }

            getConfiguration() {
                return {
                    iterations: parseInt(document.getElementById('iterations').value),
                    timeout: parseInt(document.getElementById('timeout').value),
                    testMode: document.getElementById('testMode').value
                };
            }

            getEnabledRoutes() {
                const routes = [];
                const routeElements = document.querySelectorAll('.route-entry');
                
                routeElements.forEach(element => {
                    const checkbox = element.querySelector('.route-checkbox');
                    if (checkbox && checkbox.checked) {
                        const nameInput = element.querySelector('.route-name');
                        const urlInput = element.querySelector('.route-url');
                        const typeSelect = element.querySelector('.route-type-select');
                        
                        if (nameInput && urlInput && urlInput.value.trim() !== '') {
                            routes.push({
                                name: nameInput.value || 'Unnamed Route',
                                url: urlInput.value.trim(),
                                type: typeSelect ? typeSelect.value : 'custom',
                                description: element.querySelector('.route-description')?.value || ''
                            });
                        }
                    }
                });
                
                return routes;
            }
        }

        // UI Management Functions
        function loadPresetScenario(scenarioId) {
            const scenario = presetScenarios[scenarioId];
            if (!scenario) return;
            
            // Update description
            document.getElementById('scenario-description').value = scenario.description;
            
            // Update visualization
            document.querySelector('#scenario-visualization .route-diagram').innerHTML = scenario.visualization;
            
            // Clear and rebuild routing endpoints
            const container = document.getElementById('routing-endpoints');
            container.innerHTML = '';
            routeCounter = 0;
            
            scenario.routes.forEach(route => {
                addRouteEntry(route);
            });
        }

        function addRouteEntry(routeData = null) {
            const container = document.getElementById('routing-endpoints');
            const routeId = `route-${routeCounter++}`;
            
            const route = routeData || {
                name: 'Custom Route',
                url: '',
                type: 'custom',
                description: '',
                enabled: false
            };
            
            const routeElement = document.createElement('div');
            routeElement.className = `route-entry ${route.enabled ? 'enabled' : ''}`;
            routeElement.innerHTML = `
                <div class="route-header">
                    <div style="display: flex; align-items: center;">
                        <input type="checkbox" class="route-checkbox" ${route.enabled ? 'checked' : ''} 
                               onchange="toggleRouteEntry(this)">
                        <strong style="margin-left: 8px;">${route.name}</strong>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span class="route-type ${route.type}">${route.type.toUpperCase()}</span>
                        <button class="btn btn-small" onclick="removeRouteEntry(this)" style="background: #e74c3c; padding: 4px 8px;">×</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Route Name:</label>
                    <input type="text" class="route-name" value="${route.name}" placeholder="Enter route name">
                </div>
                <div class="form-group">
                    <label>Endpoint URL:</label>
                    <input type="url" class="route-url" value="${route.url}" placeholder="https://example.com/endpoint">
                </div>
                <div class="form-group">
                    <label>Route Type:</label>
                    <select class="route-type-select" onchange="updateRouteType(this)">
                        <option value="traditional" ${route.type === 'traditional' ? 'selected' : ''}>Traditional Routing</option>
                        <option value="optimized" ${route.type === 'optimized' ? 'selected' : ''}>Optimized Routing</option>
                        <option value="reference" ${route.type === 'reference' ? 'selected' : ''}>Reference/Baseline</option>
                        <option value="custom" ${route.type === 'custom' ? 'selected' : ''}>Custom/Other</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Description:</label>
                    <input type="text" class="route-description" value="${route.description}" placeholder="Describe this routing path">
                </div>
            `;
            
            container.appendChild(routeElement);
        }

        function addCustomRoute() {
            addRouteEntry();
        }

        function removeRouteEntry(button) {
            if (confirm('Remove this routing endpoint?')) {
                button.closest('.route-entry').remove();
            }
        }

        function toggleRouteEntry(checkbox) {
            const routeEntry = checkbox.closest('.route-entry');
            if (checkbox.checked) {
                routeEntry.classList.add('enabled');
            } else {
                routeEntry.classList.remove('enabled');
            }
        }

        function updateRouteType(select) {
            const typeSpan = select.closest('.route-entry').querySelector('.route-type');
            typeSpan.className = `route-type ${select.value}`;
            typeSpan.textContent = select.value.toUpperCase();
        }

        // Main test execution
        async function runRoutingTests() {
            if (isRunning) {
                alert('Tests are already running. Please wait for completion.');
                return;
            }
            
            isRunning = true;
            updateStatus('Running routing performance tests...', 'running');
            
            document.getElementById('log-output').textContent = 'Starting routing performance tests...\n';
            document.getElementById('endpoint-status').innerHTML = '';
            
            try {
                const tester = new RoutingPerformanceTester();
                const results = await tester.runTests();
                
                testResults = results;
                
                updateOverview(results);
                updateDetailedResults(results);
                updateAnalysis(results);
                
                updateStatus('Routing performance tests completed', 'complete');
                
            } catch (error) {
                console.error('Test execution failed:', error);
                updateStatus(`Test failed: ${error.message}`, 'error');
                
                const logOutput = document.getElementById('log-output');
                logOutput.textContent += `ERROR: ${error.message}\n`;
            } finally {
                isRunning = false;
                document.getElementById('progress').style.width = '0%';
            }
        }

        function updateOverview(results) {
            const summary = results.summary;
            
            // Update metrics
            const bestLatency = document.getElementById('best-latency');
            const worstLatency = document.getElementById('worst-latency');
            const improvementMs = document.getElementById('improvement-ms');
            const improvementPercent = document.getElementById('improvement-percent');
            
            if (bestLatency && summary.bestRoute) {
                bestLatency.textContent = summary.bestRoute.success ? `${summary.bestRoute.average}ms` : 'Failed';
            }
            
            if (worstLatency && summary.worstRoute) {
                worstLatency.textContent = summary.worstRoute.success ? `${summary.worstRoute.average}ms` : 'Failed';
            }
            
            if (improvementMs && improvementPercent && summary.improvement) {
                improvementMs.textContent = `${summary.improvement.latencyReduction}ms`;
                improvementPercent.textContent = `${summary.improvement.percentageImprovement}%`;
            } else {
                if (improvementMs) improvementMs.textContent = '--';
                if (improvementPercent) improvementPercent.textContent = '--';
            }
            
            // Update summary content
            const summaryContent = document.getElementById('summary-content');
            if (!summaryContent) return;
            
            const endpointRows = summary.routeRanking
                .map((endpoint, index) => {
                    const rank = index + 1;
                    const rankEmoji = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
                    
                    return `
                        <tr>
                            <td>${rankEmoji} ${endpoint.name}</td>
                            <td>${endpoint.average}ms</td>
                            <td>${endpoint.min}-${endpoint.max}ms</td>
                            <td>±${endpoint.standardDeviation}ms</td>
                            <td>${endpoint.successRate}%</td>
                        </tr>
                    `;
                }).join('');
            
            let analysisText = '';
            if (summary.improvement && summary.improvement.latencyReduction > 0) {
                const isSignificant = summary.improvement.latencyReduction > 50;
                analysisText = `
                    <div class="${isSignificant ? 'success-box' : 'info-box'}">
                        <strong>${isSignificant ? '✅ SIGNIFICANT PERFORMANCE DIFFERENCE' : 'ℹ️ PERFORMANCE VARIATION'}</strong><br>
                        Best route (${summary.bestRoute.name}) is <strong>${summary.improvement.latencyReduction}ms faster</strong> 
                        (${summary.improvement.percentageImprovement}% improvement) than worst route (${summary.worstRoute.name}).
                        ${isSignificant ? '<br><br><strong>Recommendation:</strong> Consider optimizing to use the fastest routing path.' : ''}
                    </div>
                `;
            } else if (summary.successfulEndpoints > 0) {
                analysisText = `
                    <div class="info-box">
                        <strong>ℹ️ SIMILAR PERFORMANCE</strong><br>
                        All tested routes show similar performance characteristics. 
                        Consider other factors like reliability and cost for routing decisions.
                    </div>
                `;
            }
            
            summaryContent.innerHTML = `
                ${analysisText}
                <h4>🏆 Route Performance Ranking</h4>
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Route</th>
                            <th>Average Latency</th>
                            <th>Range</th>
                            <th>Std. Deviation</th>
                            <th>Success Rate</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${endpointRows}
                    </tbody>
                </table>
                
                <h4>📊 Test Summary</h4>
                <ul>
                    <li><strong>Scenario:</strong> ${results.scenario}</li>
                    <li><strong>Routes Tested:</strong> ${summary.totalEndpoints} (${summary.successfulEndpoints} successful)</li>
                    <li><strong>Overall Success Rate:</strong> ${summary.overallSuccessRate}%</li>
                    <li><strong>Average Latency:</strong> ${summary.averageLatency}ms</li>
                </ul>
            `;
        }

        function updateDetailedResults(results) {
            const detailedResults = document.getElementById('detailed-results');
            
            let content = '<h4>📊 Detailed Performance Metrics</h4>';
            
            const sortedEndpoints = Object.values(results.endpoints)
                .sort((a, b) => {
                    if (!a.success && !b.success) return 0;
                    if (!a.success) return 1;
                    if (!b.success) return -1;
                    return a.average - b.average;
                });
            
            sortedEndpoints.forEach((endpoint, index) => {
                const rank = endpoint.success ? index + 1 : 'Failed';
                const rankEmoji = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : '';
                
                if (!endpoint.success) {
                    content += `
                        <div class="results-container">
                            <h4>❌ ${endpoint.name} - Connection Failed</h4>
                            <p>All requests to this route failed. Check the endpoint URL and network connectivity.</p>
                        </div>
                    `;
                    return;
                }
                
                let performanceAssessment = '';
                if (endpoint.average < 200) {
                    performanceAssessment = '🚀 Excellent performance';
                } else if (endpoint.average < 350) {
                    performanceAssessment = '✅ Good performance';
                } else if (endpoint.average < 500) {
                    performanceAssessment = '⚠️ Acceptable performance';
                } else {
                    performanceAssessment = '🐌 Poor performance';
                }
                
                const sampleData = endpoint.latencies.slice(0, 10).map((latency, i) => `
                    <tr>
                        <td>${i + 1}</td>
                        <td>${latency}ms</td>
                        <td>${latency < 300 ? '🟢' : latency < 500 ? '🟡' : '🔴'}</td>
                    </tr>
                `).join('');
                
                content += `
                    <div class="results-container">
                        <h4>${rankEmoji} ${endpoint.name} ${rank !== 'Failed' ? `(Rank #${rank})` : ''}</h4>
                        <p>${performanceAssessment}</p>
                        
                        <div class="metric-grid">
                            <div class="metric-card">
                                <div class="metric-value">${endpoint.average}ms</div>
                                <div class="metric-label">Average Latency</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${endpoint.min}ms</div>
                                <div class="metric-label">Best Response</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${endpoint.max}ms</div>
                                <div class="metric-label">Worst Response</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${endpoint.successRate}%</div>
                                <div class="metric-label">Reliability</div>
                            </div>
                        </div>
                        
                        <h5>Sample Measurements (First 10 Tests)</h5>
                        <table class="results-table">
                            <thead>
                                <tr><th>Test #</th><th>Latency</th><th>Performance</th></tr>
                            </thead>
                            <tbody>
                                ${sampleData}
                            </tbody>
                        </table>
                    </div>
                `;
            });
            
            detailedResults.innerHTML = content;
        }

        function updateAnalysis(results) {
            const analysisContent = document.getElementById('analysis-content');
            const successful = Object.values(results.endpoints).filter(e => e.success);
            const summary = results.summary;
            
            if (successful.length === 0) {
                analysisContent.innerHTML = '<p>No successful tests to analyze. Check your endpoints and network connectivity.</p>';
                return;
            }
            
            // Performance ranking
            const performanceRows = successful
                .sort((a, b) => a.average - b.average)
                .map((endpoint, index) => {
                    const rank = index + 1;
                    const reliability = endpoint.successRate >= 95 ? 'Excellent' : 
                                       endpoint.successRate >= 85 ? 'Good' : 
                                       endpoint.successRate >= 70 ? 'Fair' : 'Poor';
                    const consistency = endpoint.standardDeviation < 50 ? 'Very Consistent' :
                                       endpoint.standardDeviation < 100 ? 'Consistent' :
                                       endpoint.standardDeviation < 200 ? 'Variable' : 'Highly Variable';
                    
                    return `
                        <tr>
                            <td>${rank}</td>
                            <td>${endpoint.name}</td>
                            <td>${endpoint.average}ms</td>
                            <td>${endpoint.standardDeviation}ms</td>
                            <td>${consistency}</td>
                            <td>${reliability}</td>
                        </tr>
                    `;
                }).join('');
            
            let optimizationAnalysis = '';
            if (summary.improvement && summary.improvement.latencyReduction > 0) {
                const improvement = summary.improvement;
                
                optimizationAnalysis = `
                    <div class="results-container">
                        <h4>🎯 Routing Optimization Analysis</h4>
                        
                        <div class="metric-grid">
                            <div class="metric-card">
                                <div class="metric-value" style="color: ${improvement.latencyReduction > 100 ? '#27ae60' : improvement.latencyReduction > 50 ? '#f39c12' : '#e74c3c'}">${improvement.latencyReduction}ms</div>
                                <div class="metric-label">Latency Improvement</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value" style="color: ${improvement.percentageImprovement > 30 ? '#27ae60' : improvement.percentageImprovement > 15 ? '#f39c12' : '#e74c3c'}">${improvement.percentageImprovement}%</div>
                                <div class="metric-label">Performance Gain</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${summary.bestRoute.successRate}%</div>
                                <div class="metric-label">Best Route Reliability</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${improvement.latencyReduction > 100 ? 'Excellent' : improvement.latencyReduction > 50 ? 'Good' : 'Fair'}</div>
                                <div class="metric-label">Optimization Rating</div>
                            </div>
                        </div>
                        
                        <h5>Routing Insights</h5>
                        <div class="${improvement.latencyReduction > 50 ? 'success-box' : 'info-box'}">
                            <strong>${improvement.latencyReduction > 50 ? '✅ SIGNIFICANT IMPROVEMENT OPPORTUNITY:' : 'ℹ️ MODERATE IMPROVEMENT AVAILABLE:'}</strong><br>
                            Switching from ${summary.worstRoute.name} to ${summary.bestRoute.name} provides 
                            ${improvement.latencyReduction}ms improvement (${improvement.percentageImprovement}% faster response times).
                            ${improvement.latencyReduction > 100 ? '<br><br>This represents a meaningful user experience improvement and should be considered for implementation.' : ''}
                        </div>
                    </div>
                `;
            }
            
            analysisContent.innerHTML = `
                ${optimizationAnalysis}
                
                <h4>🏆 Complete Performance Analysis</h4>
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Route</th>
                            <th>Avg Latency</th>
                            <th>Variability (±)</th>
                            <th>Consistency</th>
                            <th>Reliability</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${performanceRows}
                    </tbody>
                </table>
                
                <h4>📈 Key Insights</h4>
                <div class="results-container">
                    <ul>
                        <li><strong>Best Performing Route:</strong> ${summary.bestRoute.name} with ${summary.bestRoute.average}ms average latency</li>
                        <li><strong>Most Consistent:</strong> ${successful.reduce((min, e) => e.standardDeviation < min.standardDeviation ? e : min).name} (±${successful.reduce((min, e) => e.standardDeviation < min.standardDeviation ? e : min).standardDeviation}ms variation)</li>
                        <li><strong>Most Reliable:</strong> ${successful.reduce((max, e) => e.successRate > max.successRate ? e : max).name} (${successful.reduce((max, e) => e.successRate > max.successRate ? e : max).successRate}% success rate)</li>
                        <li><strong>Performance Spread:</strong> ${summary.worstRoute.average - summary.bestRoute.average}ms difference between fastest and slowest routes</li>
                        <li><strong>Overall Success Rate:</strong> ${summary.overallSuccessRate}% across all routes</li>
                    </ul>
                </div>
                
                <h4>💡 Recommendations</h4>
                <div class="results-container">
                    ${summary.improvement && summary.improvement.latencyReduction > 50 ? 
                        `<p><strong>High Priority:</strong> Consider implementing the ${summary.bestRoute.name} routing path for significant performance gains.</p>` :
                        `<p><strong>Monitor:</strong> Performance differences are moderate. Consider other factors like cost, reliability, and complexity.</p>`
                    }
                    <p><strong>Next Steps:</strong> Test with production traffic patterns and monitor performance over time to validate results.</p>
                </div>
            `;
        }

        // Test endpoint reachability
        async function testEndpointReachability() {
            updateStatus('Testing endpoint reachability...', 'running');
            
            const tester = new RoutingPerformanceTester();
            const routes = tester.getEnabledRoutes();
            
            if (routes.length === 0) {
                alert('No routes enabled for testing');
                updateStatus('Ready to test routing performance', 'idle');
                return;
            }
            
            tester.log('🔍 Testing endpoint reachability...');
            
            for (const route of routes) {
                try {
                    tester.updateEndpointStatus(route.name, 'Testing...', 'testing');
                    const result = await tester.measureLatency(route.url, 5000);
                    
                    if (result.success) {
                        tester.updateEndpointStatus(route.name, `✅ Reachable (${result.latency}ms)`, 'success');
                        tester.log(`${route.name}: Reachable (${result.latency}ms)`);
                    } else {
                        tester.updateEndpointStatus(route.name, `❌ ${result.error}`, 'error');
                        tester.log(`${route.name}: Failed - ${result.error}`);
                    }
                } catch (error) {
                    tester.updateEndpointStatus(route.name, `❌ ${error.message}`, 'error');
                    tester.log(`${route.name}: Error - ${error.message}`);
                }
            }
            
            updateStatus('Endpoint reachability test completed', 'complete');
        }

        // Export results
        function exportResults() {
            if (!testResults) {
                alert('No test results to export. Please run tests first.');
                return;
            }
            
            const exportData = {
                metadata: {
                    tool: 'Geographic Routing Performance Testing Tool',
                    version: '2.0.0',
                    exportTime: new Date().toISOString(),
                    testConfiguration: testResults.config,
                    testScenario: testResults.scenario
                },
                results: testResults,
                summary: testResults.summary,
                userAgent: navigator.userAgent,
                timestamp: testResults.timestamp
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `routing-performance-results-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('Routing performance results exported successfully!');
        }

        // Reset configuration
        function resetConfiguration() {
            if (confirm('Reset all configuration to default values?')) {
                document.getElementById('iterations').value = 30;
                document.getElementById('timeout').value = 15;
                document.getElementById('testMode').value = 'ping';
                
                loadPresetScenario('sa-au-nz');
                
                document.getElementById('endpoint-status').innerHTML = '';
                
                updateStatus('Configuration reset to defaults', 'idle');
            }
        }

        // Tab management
        function showTab(tabName) {
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            
            const clickedTab = Array.from(document.querySelectorAll('.tab')).find(tab => 
                tab.getAttribute('onclick').includes(tabName)
            );
            if (clickedTab) {
                clickedTab.classList.add('active');
            }
        }

        // Status management
        function updateStatus(message, type = 'idle') {
            const statusElement = document.getElementById('status');
            const indicator = statusElement.querySelector('.status-indicator');
            
            indicator.className = `status-indicator status-${type}`;
            statusElement.querySelector('span:last-child').textContent = message;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadPresetScenario('sa-au-nz'); // Load default scenario
            updateStatus('Ready to test routing performance', 'idle');
        });
    </script>
</body>
</html>